<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<title>Canvas Test</title>

		<script>
			
			const CLOCK_WISE 					= true;
			const COUNTER_CLOCK_WISE	= false;
			const FRAME_TIME					= 1000 / 30; //milliseconds
			const GRAVITY_CONSTANT		= 9.80665;
			const PIXEL_PER_METER			= 200;
			const VELOCITY_MAX				= 4; //Velocity in meter/second
			const SHIP_ROTATION_UNIT	= Math.PI * 2; //Rotation allowed per frame
			const SHIP_BOOST_UNIT			= 0.1; //Velocity in meter/second

			const Vector2D = {
				create(x,y) {
					let v = Object.create(this.template);
					v.x = x;
					v.y = y;
					return v;
				},

				zero() {
					return this.create(0,0);
				},

				template: {
					x: 0,
					y: 0,

					add(vector2D) {
						result = Vector2D.zero();
						result.x = vector2D.x + this.x;
						result.y = vector2D.y + this.y;
						return result;
					},

					scalarMultiply(scalar) {
						result = Vector2D.zero();
						result.x = this.x * scalar;
						result.y = this.y * scalar;
						return result;
					},

					copy() {
						return Vector2D.create(this.x, this.y);
					},

					resize(size) {
						return this.scalarMultiply(size / this.distance());
					},

					distance() {
						return Math.sqrt((this.x * this.x) + (this.y * this.y));
					},

					cut(size) {
						if (this.distance() > size) {
							return this.resize(size);
						}
						return this.copy();
					},

					rotate(angle) {
						return Vector2D.create(
							this.x = Math.cos(angle) - this.y * Math.sin(angle),
							this.y = Math.sin(angle) + this.y * Math.cos(angle)
						);
					},

					toString() {
						return "{x:" + this.x + ",y:" + this.y + "}";
					}

				}
			};

			const Ship = {
				create() {
					return Object.create(this.template);
				},

				template: {
					isBoost:  false,
					isLeft:   false,
					isRight:  false,
					position: Vector2D.create(1,1), //Game space coordinates
					velocity: Vector2D.create(1,0), //Velocity in meter/second
					direction: 0, //Radian

					updatePosition(elapsedTime /*frame duration in second*/) {
						//Update velocity
						this.velocity = (GRAVITY_VECTOR.scalarMultiply(elapsedTime))
							.add(this.velocity)
							.cut(VELOCITY_MAX);
						//Update position
						this.position = this.position
							.add(this.velocity.scalarMultiply(elapsedTime));
					},

					updateControl(elapsedTime /*frame duration in second*/) {

						//Update direction
						if (this.isLeft) {
							this.direction = this.direction - (SHIP_ROTATION_UNIT * elapsedTime);
						} else if (this.isRight) {
							this.direction = this.direction + (SHIP_ROTATION_UNIT * elapsedTime);
						}

						//Update boost
						if (this.isBoost) {
							let boost = SHIP_BOOST_UNIT * elapsedTime;
							this.velocity = this.velocity
								.add(Vector2D.create(boost,0).rotate(this.direction));
						}

					}
				}

			};

			const GRAVITY_VECTOR = Vector2D.create(0,GRAVITY_CONSTANT);

			var ship = Ship.create();
			var lastTime = (new Date()).getTime();

			function meter2Pixel(distanceInMeter) {
				return distanceInMeter * PIXEL_PER_METER;
			}

			function pixel2Meter(distanceInPixel) {
				return distanceInPixel / PIXEL_PER_METER;
			}

			function vectorMeter2Pixel(v) {
				return v.scalarMultiply(PIXEL_PER_METER);
			}

			function vectorPixel2Meter(v) {
				return v.scalarMultiply(1 / PIXEL_PER_METER);
			}

			function draw() {

				let debugDiv = document.getElementById("debug");
				debugDiv.textContent = ship.velocity.toString();

				//Calculate the elapsed time
				let newTime = (new Date()).getTime();
				let elapsedTime = (newTime - lastTime) / 1000; //Elapsed time in second
				lastTime = newTime;

				ship.updateControl(elapsedTime);
				ship.updatePosition(elapsedTime);

				//Keep in the screen
				let canvas = document.getElementById("canvas");
				if (ship.position.x >= pixel2Meter(canvas.width)) {
					ship.position.x = pixel2Meter(canvas.width - 1);
					ship.velocity.x = 0;
					ship.velocity.y = 0;
				}
				if (ship.position.x < 0) {
					ship.position.x = 0;	
					ship.velocity.x = 0;
					ship.velocity.y = 0;
				}
				if (ship.position.y >= pixel2Meter(canvas.height)) {
					ship.position.y = pixel2Meter(canvas.height -1);
					ship.velocity.y = 0;
					ship.velocity.x = 0;
				}
				if (ship.position.y < 0) {
					ship.position.y = 0;
					ship.velocity.y = 0;
					ship.velocity.x = 0;
				}

				let canvasContext = canvas.getContext("2d"); //Get the draw context
				canvasContext.clearRect(0,0,canvas.width, canvas.height); //Clear context

				{
					/* Draw the ship. Look like the following:
					*      X
					*  X   X
					*  XXXXXXX
					*  X   X
					*      X
					*/
					//Set the color of the ship
					canvasContext.fillStyle = "black";

					let screenCoordinates = vectorMeter2Pixel(ship.position);
					canvasContext.save();
					canvasContext.translate(screenCoordinates.x, screenCoordinates.y);
					canvasContext.rotate(ship.direction);
					canvasContext.fillRect(-60/2,-5,60,10);
					{
						canvasContext.save();
						canvasContext.translate(10,0);
						canvasContext.fillRect(-5,-70/2,10,70);
						canvasContext.restore();
					}
					{
						canvasContext.save();
						canvasContext.translate(-25,0);
						canvasContext.fillRect(-5,-30/2,10,30);
						canvasContext.restore();
					}
					canvasContext.restore();
				}

			}

			window.onload = function() {
				window.setInterval(draw,FRAME_TIME);
			};

			window.onkeydown = function(event) {
				switch (event.which) {
					case 87: //E
						ship.isBoost = true;
						break;
					case 65: //A
						ship.isLeft = true;
						break;
					case 68: //D
						ship.isRight = true;
						break;
				}
			}

			window.onkeyup = function(event) {
				switch (event.which) {
					case 87: //E
						ship.isBoost = false;
						break;
					case 65: //A
						ship.isLeft = false;
						break;
					case 68: //D
						ship.isRight = false;
						break;
				}
			}

		</script>

	</head>

	<body>
		<canvas id="canvas" width="800" height="600" style="border-style: solid">
		</canvas>
		<div id="debug">
		</div>
	</body>

</html>
